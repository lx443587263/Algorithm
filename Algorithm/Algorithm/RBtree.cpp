/* The codes below are generated by 'Element Studio'. */
#include <stdlib.h>
enum Color
{
	Black = 0,
	Red
};
typedef struct _RBNode
{
	enum Color color;
	unsigned key;
	char value;
	struct _RBNode * left;
	struct _RBNode * right;
} RBNode, *PRBNode;
PRBNode insert(PRBNode root, PRBNode node);
PRBNode create_node(unsigned key, char value);
PRBNode remove(PRBNode root, unsigned key);
int main(int ac, char * av[])
{
	PRBNode root = insert(NULL, create_node(5, 'a'));
	root = insert(root, create_node(7, 'b'));
	root = insert(root, create_node(9, 'c'));
	root->color = Black;
	return 0;
}
void exchange_color(PRBNode a, PRBNode b)
{
	enum Color color = a->color;
	a->color = b->color;
	b->color = color;
}
void flip_color(PRBNode root)
{
	root->color = Red;
	root->left->color = Black;
	root->right->color = Black;
}
PRBNode left_rotate(PRBNode root)
{
	PRBNode x = root->right;
	root->right = x->left;
	x->left = root;
	exchange_color(root, x);
	return x;
}
PRBNode right_rotate(PRBNode root)
{
	PRBNode x = root->left;
	root->left = x->right;
	x->right = root;
	exchange_color(root, x);
	return x;
}
bool is_red(PRBNode root)
{
	if (!root)
	{
		return false;
	}
	return root->color == Red ? true : false;
}
PRBNode move_right_left(PRBNode root)
{
	root->color = Red;
	root->left->color = Red;
	root->right = right_rotate(root->right);
	root = left_rotate(root);
	root->right->color = Black;
	if (is_red(root->right->right))
	{
		root->right = left_rotate(root->right);
	}
	return root;
}
PRBNode move_left_right(PRBNode root)
{
	root->color = Red;
	root->right->color = Red;
	if (is_red(root->left->right))
	{
		root->left = left_rotate(root->left);
	}
	root = right_rotate(root);
	root->left->color = Black;
	root->right = left_rotate(root->right);
	return root;
}
void reverse_flip_color(PRBNode root)
{
	root->color = Black;
	root->left->color = Red;
	root->right->color = Red;
}
PRBNode remove_min(PRBNode root)
{
	if (!root->left)
	{
		free(root);
		return NULL;
	}
	if (is_red(root->left))
	{
		root->left = remove_min(root->left);
	}
	else if (is_red(root->right->left))
	{
		root = move_right_left(root);
		root->left->left = remove_min(root->left->left);
	}
	else if (!is_red(root->right->left))
	{
		reverse_flip_color(root);
		root->left = remove_min(root->left);
	}
	else
	{
		root->left = remove_min(root->left);
	}
	if (!is_red(root->left) && is_red(root->right))
	{
		root = left_rotate(root);
	}
	if (is_red(root->left) && is_red(root->left->left))
	{
		root = right_rotate(root);
	}
	return root;
}
PRBNode remove_max(PRBNode root)
{
	if (!is_red(root->left) && !root->right)
	{
		free(root);
		return NULL;
	}
	if (is_red(root->right))
	{
	}
	else if (is_red(root->left))
	{
		root = right_rotate(root);
	}
	else if (is_red(root->left->left))
	{
		root = move_left_right(root);
	}
	else if (!is_red(root->left->left))
	{
		reverse_flip_color(root);
	}
	root->right = remove_max(root->right);
	if (!is_red(root->left) && is_red(root->right))
	{
		root = left_rotate(root);
	}
	return root;
}
PRBNode create_node(unsigned key, char value)
{
	PRBNode node = (PRBNode)(malloc(sizeof(RBNode)));
	node->key = key;
	node->value = value;
	node->left = NULL;
	node->right = NULL;
	node->color = Red;
	return node;
}
void exchange(PRBNode a, PRBNode b)
{
	unsigned key = a->key;
	char value = a->value;
	a->key = b->key;
	a->value = b->value;
	b->key = key;
	b->value = value;
}
PRBNode find_min(PRBNode root)
{
	PRBNode node = root;
	while (node->left)
	{
		node = node->left;
	}
	return node;
}
PRBNode insert(PRBNode root, PRBNode node)
{
	if (!root)
	{
		return node;
	}
	if (root->key == node->key)
	{
		root->value = node->value;
		return root;
	}
	if (is_red(root->left) && is_red(root->right))
	{
		flip_color(root);
	}
	if (node->key < root->key)
	{
		root->left = insert(root->left, node);
	}
	else
	{
		root->right = insert(root->right, node);
	}
	if (!is_red(root->left) && is_red(root->right))
	{
		root = left_rotate(root);
	}
	if (is_red(root->left) && is_red(root->left->left))
	{
		root = right_rotate(root);
	}
	return root;
}
PRBNode remove(PRBNode root, unsigned key)
{
	if (!root)
	{
		return NULL;
	}
	else if (root->key == key && !root->left && !root->right)
	{
		free(root);
		return NULL;
	}
	if (key < root->key)
	{
		if (is_red(root->left))
		{
		}
		else if (is_red(root->right->left))
		{
			root = move_right_left(root);
		}
		else if (!is_red(root->right->left))
		{
			reverse_flip_color(root);
			root->left = remove_min(root->left);
		}
		root->left = remove(root->left, key);
	}
	else if (key > root->key)
	{
		if (is_red(root->right))
		{
		}
		else if (is_red(root->left))
		{
			root = right_rotate(root);
		}
		else if (is_red(root->left->left))
		{
			root = move_left_right(root);
		}
		else if (!is_red(root->left->left))
		{
			reverse_flip_color(root);
		}
		root->right = remove(root->right,key);
	}
	else
	{
		PRBNode min_node = find_min(root->right);
		exchange(root, min_node);
		root->right = remove_min(root->right);
	}
	if (!is_red(root->left) && is_red(root->right))
	{
		root = left_rotate(root);
	}
	return root;
}
